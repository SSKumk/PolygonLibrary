% Preamble
\documentclass[a4paper,12pt]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[utf8]{inputenc}         % кодировка исходного текста
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[a4paper, margin=20mm]{geometry}
\usepackage{hyperref}               % активные сслыки

% Packages
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{mathrsfs} % \mathscr{} ажурный шрифт

\usepackage{indentfirst} %абзацный отступ
\usepackage{ifthen}      %поддержка \ifthanelse{}{}{}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[shortcuts]{extdash}
%-----------
%\newcommand{\}{}
\newcommand{\scalprod}[3][]{#1\langle #2, #3 #1\rangle} % Скалярное произведение
\DeclareMathOperator{\argmin}{arg\.min}
\DeclareMathOperator{\argmax}{arg\.max}
\DeclareMathOperator{\Argmin}{Arg\.min}
\DeclareMathOperator{\Argmax}{Arg\.max}


\renewcommand{\.}{\hspace{0.2ex}}


\begin{document}

\section{Алгоритм перевода гиперплоскостного описания многогранника в вершинное представление}

  Пусть дан набор $\mathcal{H}$ гиперплоскостей, возможно избыточный, описывающий многогранник. Нормали смотрят наружу.

  \textit{Этап 1}. Найти какую-нибудь вершину многогранника и набор гиперплоскостей, в ней сходящихся. \\
  Наивный перебор / симплекс-метод = поиск точки. Поиск гиперплоскостей = подстановка точки в каждую гиперплоскость.

  ??? Есть ли у нас симплекс-метод, останавливающийся после нахождения какой-либо вершины (начальное решение). ?Alglib?

  \textit{Этап 2}. Найти оставшиеся вершины многогранника.

  Создадим очередь из пар (вершина, набор индексов гиперплоскостей), из которых мы ещё не строили рёбра. Инициализируем её данными, найденными на первом этапе.

  Пока очередь не пуста:

  Берём очередную вершину $z$ из очереди. Из построения этой вершины известен набор~$\mathcal{H}_z$ гиперплоскостей, проходящих через эту точку.

  Перебираем всевозможные наборы $J$ индексов совокупностей из $d-1$ гиперплоскостей из набора $\mathcal{H}_z$.

  Для каждого такого набора

  а) ортогонализируем его с помощью метода Г-Ш;

  б) с помощью Г-Ш на орты пространства построим направляющий вектор~$v$ прямой, получающейся в пересечении этого набора.

  Проверяем вектор $v$. Идём по нормалям $n$ гиперплоскостей из набора $\mathcal{H}_z$ и считаем скалярное произведение $\scalprod{v}{n}$. Если оно равно нулю, то игнорируем. Первое ненулевое скалярное произведение определяет ориентацию вектора $v$: если положительное, то меняем $v$ на противоположный. Для всех последующих не нулевых произведений требуется, чтобы они были неотрицательны.

  Если вектор прошёл фильтрацию, то он вместе с текущей вершиной $z$ определяет луч, содержащий ребро. Обозначим его $v_*$. Иначе переходим к следующему набору гиперплоскостей.

  Найдём все гиперплоскости из набора $\mathcal{H} \backslash \mathcal{H}_z $, наиболее близкие к $z$ в направлении $v_*$:
  $$
  J' = \Argmin \left\{i \, \Big{|} \, t_i = \frac{b_i - \scalprod{n_i}{z}}{\scalprod{n_i}{v_*}}, t_i > 0\right\}.
  $$
  Если знаменатель дроби равен нулю, то считаем $t_i = +\infty$.

  Также в процессе запоминаем $t'$, соответствующее набору $J'$:

  --- в начале $t' = +\infty$, $J' = \varnothing$;

  --- берём очередную полуплоскость, вычисляем её $t_i$;

  --- если $t_i \leqslant 0$ или $t_i > t'$, то переходим к следующей полуплоскости;

  --- если $t_i = t'$, то добавляем $i$ в $J'$ и переходим к следующей полуплоскости;

  --- если $t_i < t'$, то $t' = t_i$, $J' = \{i\}$; вычисляем новую вершину $z' = z + t' v_*$; если вершина $z'$ в наборе уже известных вершин, то останавливаем обработку текущего ребра и переходим к новому набору $J$, иначе переходим к следующей полуплоскости.



  Добавляем в очередь пару $(z', J \cup J')$ как вершину многогранника и набор гиперплоскостей, в ней сходящийся.



\end{document}