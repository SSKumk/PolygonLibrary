% Preamble
\documentclass[a4paper,12pt]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[utf8]{inputenc}         % кодировка исходного текста
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[a4paper, margin=20mm]{geometry}
\usepackage{hyperref}               % активные сслыки

% Packages
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{mathrsfs} % \mathscr{} ажурный шрифт

\usepackage{indentfirst} %абзацный отступ
\usepackage{ifthen}      %поддержка \ifthanelse{}{}{}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[shortcuts]{extdash}


\newcommand{\R}[1][]{% R - евклидово пространство
  \ifthenelse{\equal{#1}{}}%
  {\mathbb{R}}%
  {\mathbb{R}^{#1}}}
\newcommand{\A}[1]{\mathbb{A}^{#1}}           % A - аффинное пространство
\newcommand{\Swarm}{\mathcal{S}}              % Swarm - рой точек
\newcommand{\Polytop}{\mathcal{P}}         % Polyhedron - многогранник
\newcommand{\PolyhedronComplex}{\mathcal{PC}} % Polyhedron Complex - многогранник
\newcommand{\Facet}{\mathcal{F}}              % Facet - грань
\newcommand{\Edge}{\mathcal{E}}               % Edge - ребро
\newcommand{\Basis}{\mathcal{B}}              % Basis - базис
\newcommand{\Viewed}{\mathcal{V}}             % Viewed - множество просмотренных точек
\newcommand{\Normal}{\mathcal{N}}             % Normal - нормаль
\newcommand{\ZVec}{\vec 0}                    % Ноль-вектор


\newcommand{\norm}[2][]{#1\lVert #2 #1\rVert}             % Норма
\newcommand{\set}[2][]{#1\{ #2 #1\}}                    % Скобки множества
\newcommand{\scalprod}[3][]{#1\langle #2, #3 #1\rangle} % Скалярное произведение
\newcommand{\Norm}[2][]{\mathcal{N}#1( #2 #1)} % Операция нормирования вектора   (первый необязательный аргумент используется для модификатора скобочек)
\newcommand{\ONorm}[3][]{\mathcal{ON}#1( #2, #3 #1)} % Операция ортонормирование вектора (первый необязательный аргумент используется для модификатора скобочек)


\newcommand{\TempVec}{\mathbf{T}}  % Temprary vector - множество временных векторов базиса
\newcommand{\FinalVec}{\mathbf{F}} % Final vector - множество финальных векторов базиса
\newcommand{\BasisOf}[1]{\mathbf{B}(#1)}   % Basis of - базис множества
\newcommand{\Plane}{\mathcal{L}}           % Плоскость
\newcommand{\SwarmPoint}{s}                % Точка роя


\renewcommand{\.}{\hspace{0.2ex}}

\begin{document}
\textbf{\centerline{Алгоритм овыпукления в $\R[d]$}}


\section{Обозначения и определения}
  $dD$ -- четырёх и более мерное пространство.

  $hD$ -- трёх- или более мерное пространство.

  Евклидово пространство $\R[d]$, $d > 1$. Его элементы обозначим $\vec x = ( x_i )_{i = 1}^{d}$.

  Ноль-вектор будем обозначать $\ZVec$.

  Аффинное пространство $\A{d}$, $d > 1$. Его элементы обозначим $x = [ x_i ]_{i = 1}^{d}$.

  Элементу $x \in \A{d}$ сопоставляется элемент $\vec x \in \R[d]$, который есть радиус\=/вектор точки $x$.

  Определены операции умножения на скаляр, сложения и вычитания. Над элементами $\R[d]$ они определяются классическим образом как операции линейного пространства. Для аффинного пространства $\A{d}$ определения следующие:
  \begin{itemize}
    \item $\forall \alpha \in \R$ $\forall x = [x_i] \in \A{d}$ $\alpha \cdot x = \alpha x = [\alpha \cdot x_i] \in \A{d}$;
    \item $\forall a \in \A{d}$ $\forall \vec x \in \R[d]$ $a + \vec x = [a_i + x_i] \in \A{d}$;
    \item $\forall a,b \in \A{d}$ $a - b = (a_i - b_i) \in \R[d]$.
  \end{itemize}

  Линейная независимость векторов из $\R[d]$ понимается в классическом смысле линейной независимости в линейном пространстве.

  Линейная независимость набора точек $\{ a_k \}_{k=0}^m \subset \A{d}$, $m \leqslant d$, понимается как линейная независимость набора векторов $\{ a_k - a_0 \}_{k=1}^m \subset \R[d]$.

  $k$\=/мерным симплексом ($k$\=/симплексом) в пространстве $\A{d}$, $k \leqslant d$, назовём линейно независимый набор $k+1$ точек.

  Базис линейного пространства $\R[d]$ понимается в классическом смысле. Аффинный базис аффинного пространства $\A{d}$ может представляться в двух эквивалентных формах: либо как $d$\=/симплекс этого пространства, либо как пару $\big(o, \{\vec x_i\}_{i=1}^d \big)$, $o \in \A{d}$, $\vec x_i \in \R[d]$, такую что набор точек $\{o, o + \vec x_i\}_{i=1}^d$ линейно независим.

  Назовём $(d-1)$\=/грань $d$\=/многогранника \textit{симплициальной}, если она имеет ровно $d$ вершин (является $(d-1)$\=/симплексом).

  %Алгоритм принимает на вход рой точек $\Swarm$ из $\R[d]$.

  %\underline{Результат -- выпуклый многогранник $\Polyhedron$}.

  Под словом <<плоскость в пространстве $\R[d]$>> будем понимать гиперплоскость размерности $\R[d-1]$.

  Вектор $\vec e_i = (\delta_{i,k})_{k=1}^d$ -- $i$\=/й вектор ортонормированного базиса $\R[d]$.
  Здесь $\delta_{i,k}$ -- символ Кр\'{о}некера:
  $$
  \delta_{i,k} =
  \begin{cases}
    1, & i=k, \\
    0, & i\neq k.
  \end{cases}
  $$

  Обозначим через $\Norm{\vec x}$ операцию нормирования вектора: $\Norm{\vec x} = \vec x \big / \norm{\vec x}$. Считаем, что $\Norm{\ZVec} = \ZVec$.

  Обозначим через $\ONorm{\vec v \.}{\Basis}$ операцию ортонормирования вектора $\vec v$ на фоне ортонормированного набора векторов $\Basis$. Выполняется с использованием алгоритма Грамма-Шмидта. Считаем, что $\ONorm{\vec a}{\varnothing} = \Norm{\vec a}$.


\section{Построение начальной грани $\Polytop$}
  Пусть $\Swarm \subset \R[d]$ -- рой $d$-мерных точек в $d$-мерном пространстве.
  Пусть $\Basis$ -- базис текущей плоскости. Построение начальной грани состоит из двух шагов. Первый -- поиск аффинной плоскости, содержащей какую-либо грань выпуклой оболочки $\Polytop$. Второй -- поиск вершин этой грани. Построение аффинной плоскости заключается в последовательном повороте некоторой начальной плоскости, проходящей через одну точку роя. Каждый поворот аффинной плоскости заключается в подмене одного вектора из её базиса так, чтобы она проходила через ещё хотя бы одну точку роя. Когда очередная плоскость содержит $d$ линейно независимых точек, искомая плоскость построена.

  Временные векторы базиса $\TempVec$ -- векторы из этого множества могут быть заменены.

  Финальные векторы базиса $\FinalVec$ -- векторы базиса, которые далее не будут заменяться и будут входить в базис искомой плоскости.

  Если требуется построить выпуклую оболочку в двумерном пространстве, то запускается какой-либо плоский алгоритм построения выпуклой оболочки. Иначе запускается следующий многомерный алгоритм, вообще говоря, рекурсивный по размерности овыпукляемых роёв.

  \subsection{Построение начальной плоскости $\Plane$ по Сварту\footnote{Swart, Garret. ``Finding the Convex Hull Facet by Facet.'' J. Algorithms 6 (1985): 17--48.}}
    \label{InitialPlaneSwart}

    Вход: $\Swarm \subset \R[d]$ -- рой точек в $d$-мерном пространстве.

    Выход: Начальная плоскость $\Plane \subset \R[d]$, заданная аффинным базисом $(o,\Basis)$, где размерность линейного базиса равна $d-1$. Внешняя нормаль $\vec n$ к этой плоскости.

    \begin{enumerate}
      \item Выберем точку $o \in \Swarm$, минимальную в лексикографическом порядке (она гарантировано будет вершиной $\Polytop$);


      \item Проведём через $o=(o_i)_{i = 1}^{d}$ плоскость $\Plane$ перпендикулярно первому базисному вектору пространства. (Все точки роя $\Swarm$ гарантированно лежат не левее этой плоскости.) Положим $\FinalVec_0 = \varnothing$, $\TempVec_0 = \set{\vec e_i}_{i=2}^d$.


      \item Положим нормаль к плоскости $\vec n_0 = -\vec e_1$.


      \item Пока $\TempVec \neq \varnothing$, повторяем:


      \begin{enumerate}
        \item Имеем $\vec n_k$ --- нормаль к текущей плоскости, $\FinalVec_k$ --- накопленная часть базиса плоскости такая, что $(o, \FinalVec_k)$ --- аффинный базис тех точек, которые уже просмотрены и включены в плоскость. $\TempVec_k$ --- оставшаяся часть временного базиса.


        \item Возьмём произвольный $\vec t \in \TempVec_k$. Удалим вектор $\vec t$ из $\TempVec_k$: $\TempVec_{k+1} \leftarrow \TempVec_k \setminus \set{\vec t \,}$.


        \item Вычислим вектор $\vec v$, перпендикулярный оси вращения: $\vec v = \ONorm{\vec t}{\FinalVec_k}$.


        \item Возьмём произвольную точку $s \in \Swarm$. Рассмотрим вектор $\vec u = \scalprod{s - o}{\vec v \.}\vec v + \scalprod{s - o}{\vec n_k}\vec n_k$~--- вектор, перпендикулярный оси вращения и лежащий в новой плоскости, содержащей точку $s$. Если $\vec u = \ZVec$, то есть точка $s$ лежит в оси вращения, то переходим на шаг~\ref{item:searchSwart}.
        \label{item:searchSwart}


        \item Иначе найдём вычислим угол между $\vec v$ и $\vec u$. Если он больше текущего максимального угла, то запоминаем его, точку $s$ и вектор $\Norm{u}$. Переходим на шаг~\ref{item:searchSwart}.


        \item Если точка $s_*$ не нашлась, это означает, что весь рой~$\Swarm$ лежит в аффинном подпространстве размерности меньше~$d-1$. В этом случае или алгоритм прекращает работу, если целью было найти выпуклую оболочку полной размерности, или переходит к построению выпуклой оболочки роя~$\Swarm$ в найденном аффинном подпространстве с базисом $(o, \FinalVec_k)$.
        \label{item:stopSwart}


        \item  Если таких экстремальных точек несколько, то можно выбрать любую. Расширим финальный базис: $\FinalVec_{k+1} \leftarrow \FinalVec_k \cup \set[\big]{\ONorm{s_* - o}{\FinalVec_k}}$.


        \item Вычислим нормаль $\vec n_{k+1}$ новой плоскости: $\vec n_{k+1} = \scalprod{\vec u\.^*}{\vec n_k}\vec v - \scalprod{\vec u\.^*}{\vec v \.}\vec n_k$. При необходимости надо переориентировать $\vec n_{k+1}$ так, чтобы $\scalprod{\vec n_{k+1}}{s - o} < 0$, где~$s$~---~точка роя, не лежащая в текущей плоскости, то есть такая, что $\scalprod{\vec n_{k+1}}{s - o} \neq 0$. Если такой точки не нашлось, значит все точки лежат в аффинном подпространстве с базисом $(o, \FinalVec_{k+1})$. Аналогично пункту~\ref{item:stopSwart} либо останавливаем алгоритм, либо переходим к построению выпуклой оболочки в этом аффинном подпространстве.


      \end{enumerate}


      \item Положим аффинный базис начальной плоскости $(o, F_k)$, $\vec n = \vec n_k$.

      \item Конец процедуры.
    \end{enumerate}

  \subsection{Построение начальной плоскости $\Plane$ нашим методом.}
    \label{subsec:InitialPlaneUs}

    Вход: $\Swarm \subset \R[d]$ -- рой точек в $d$-мерном пространстве.

    Выход: Начальная плоскость $\Plane \subset \R[d]$, заданная аффинным базисом $(o,\Basis)$, где размерность линейного базиса равна $d-1$. Внешняя нормаль $\vec n$ к данной плоскости.

    \begin{enumerate}
      \item Выберем точку $o \in \Swarm$, минимальную в лексикографическом порядке (она гарантировано будет вершиной $\Polytop$);


      \item Проведём через $o=(o_i)_{i = 1}^{d}$ плоскость $\Plane$ перпендикулярно первому базисному вектору пространства. (Все точки роя $\Swarm$ гарантированно лежат не левее этой плоскости.) Положим $\FinalVec_0 = \set{o}$, $\TempVec_0 = \set{\vec e_i}_{i=2}^d$.


      \item Обозначим $\Viewed$ -- множество просмотренных вершин плоскости $\Plane$. Положим $\Viewed =\set{o}$.


      \item Пока $\TempVec_k \neq \varnothing$, повторяем:


      \begin{enumerate}
        \item Возьмём произвольный $\vec t \in \TempVec_k$. Удалим вектор $\vec t$ из $\TempVec_k$: $\TempVec_k \leftarrow \TempVec_k \setminus \set{\vec t \,}$. Будем вращать вокруг ребра, аффинный базис которого есть $(o, E)$, где $E = \FinalVec_k \cup \TempVec_k$.


        \begin{enumerate}
          \item Будем искать точку $s_*$ такую, что на ней достигается максимум угла между $t$ и $s - o$.


          \item Пока можем взять произвольную точку $s \in \Swarm$, $s \notin \Viewed$. Пусть $\vec u_F = \ONorm{s - o}{\FinalVec_k}$. Если $\vec u_F = \ZVec$, то есть набор $\FinalVec_k \cup \set{s - o}$ линейно зависим, то добавляем точку $s$ в множество $\Viewed$ и переходим на шаг~\ref{item:searchUs}.
          \label{item:searchUs}


          \item Иначе вычислим вектор $\vec u = \ONorm{\vec u_F}{\TempVec_k}$. Если $\vec u = \ZVec$, то есть набор $\TempVec_k \cup \set{\vec u_F}$ линейно зависим, то переходим на шаг~\ref{item:searchUs}. (В этом случае мы не добавляем точку во множество просмотренных вершин, так как она ещё может пригодиться).


          \item Иначе вычислим угол между $\vec u$ и $\vec t$. Если он больше текущего максимума, то запомнить текущий угол и данную точку $s$. Угол между двумя векторами может быть вычислен как арккосинус от скалярного произведения векторов делённых на их длину. Переходим на шаг~\ref{item:searchUs}.
        \end{enumerate}


        \item Если точка $s_*$ не нашлась, это означает, что весь рой~$\Swarm$ лежит в аффинном подпространстве размерности меньше~$d-1$. В этом случае или алгоритм прекращает работу, если целью было найти выпуклую оболочку полной размерности, или переходит к построению выпуклой оболочки роя~$\Swarm$ в найденном аффинном подпространстве с базисом $(o, \FinalVec_k)$.


        \item  Если таких экстремальных точек несколько, то можно выбрать любую. Пусть $\vec v = \ONorm{s_* - o}{\FinalVec_k}$. Добавим вектор $\vec v$ в финальный базис: $\FinalVec_{k+1} \leftarrow \FinalVec_k \cup \set{\vec v \.}$. Добавим точку~$s_*$ в множество $\Viewed$.


        \item  Пересчитаем $\TempVec_k$ в $\TempVec_{k+1}$ на фоне $\FinalVec_{k+1}$.
        \begin{enumerate}


          \item $\TempVec' \leftarrow \varnothing$.


          \item  Для всех векторов $\vec t \in \TempVec_k$ ортогонализируем его на фоне текущего финального базиса, после чего ортогонализируем на фоне текущего накопленного $\TempVec'$ и добавляем получившийся вектор в $\TempVec'$:


          \item $\TempVec' \leftarrow \ONorm{\vec t}{\FinalVec \cup \TempVec'} = \ONorm{\ONorm{\vec t}{\FinalVec}}{ \TempVec'}$.

          \item Положим $\TempVec_{k+1} \leftarrow \TempVec'$.


        \end{enumerate}

        \item Возвращаемся в начало цикла.

      \end{enumerate}


      \item Вычислим внешнюю нормаль к начальной плоскости (см.~\ref{help:OrientNormal}).

      \item Положим $\vec n \leftarrow \vec n_k$, аффинный базис начальной плоскости $(o, \FinalVec)$.


      \item Конец процедуры.

    \end{enumerate}

  \subsection{Построение грани}
    \label{FacetConstruction}

    Вход: Рой точек $\Swarm \subset \R[d]$ и плоскость $\Plane \subset \R[d]$, то есть аффинный базис $(o, \Basis)$. Возможна передача $(d-2)$\=/ребра $\Edge$, являющегося начальной гранью для процедуры овыпукления в $(d-1)$\=/пространстве плоскости $\Plane$.

    Выход: $(d-1)$\=/грань $\Facet \subset \R[d]$, лежащая в плоскости $\Plane$.

    \begin{enumerate}
      \item Пусть $\Swarm_\Plane$~--- множество точек $\Swarm \subset \R[d]$, лежащих в плоскости $\Plane$.


      \item Если $|\Swarm_\Plane| = d$, то полученная грань симплициальна, дальнейшая обработка не требуется. Искомая грань --- симплекс, построенный на $d$ данных точках.


      \item Иначе проецируем $\Swarm_\Plane$ на $\Plane$ используя аффинный базис (предварительно запоминая из какой точки $s \in \Swarm$ получилась очередная точка $s' \in \Plane$) и рекурсивно строим выпуклую оболочку в аффинном подпространстве плоскости $\Plane$, если передано ребро~$\Edge$, то проецируем его на $\Plane$ и передаём в процедуру овыпукления в подпространстве (см.~\ref{subsec:GW}).


      \item Результатом овыпукления в подпространстве плоскости будет $(d-1)$\=/многогранник выраженный в терминах $(d-1)$\=/пространства, поэтому <<поднимаем>> его в $d$-мерное исходное пространство: очередную вершину $s'$ подменяем исходной для неё точкой~$s$. Производим аналогичную операцию для всех дочерних объектов данного многогранника.


      \item На данном этапе можно убрать некоторые вершины из роя $\Swarm$. В результате овыпукления данного роя получился набор $V$ вершин выпуклого многогранника. Значит из $\Swarm$ можно выкинуть все точки содержащиеся в разности $\Swarm_\Plane$ и $V$. Данные точки точно не будут состоять в выпуклой оболочке всего роя.


      \item Конец процедуры.
    \end{enumerate}


\section{Процесс заворачивания}
  Можно рассмотреть граф граней искомой выпуклой оболочки $\Polytop$. Вершины графа сопоставляются с гранями $\Polytop$. Две вершины являются соседними, если соответствующие им~$(d-1)$\=/грани имеют общее~$(d-2)$\=/ребро.

  В начале процесса заворачивания нам известна какая-то вершина этого графа, соответствующая грани, построенной алгоритмом из предыдущего раздела. Также нам известны рёбра графа, выходящие из этой вершины, так как нам известны рёбра этой начальной грани.

  В таком рассмотрении построение выпуклой оболочки соответствует обходу всех её граней, то есть обходу графа граней~$\Polytop$. Такой обход графа может быть осуществлён каким-либо поисковым алгоритмом. Наиболее компактную реализацию имеет алгоритм поиска в глубину. Эта реализация является рекурсивной.

  Напомним, что один рекурсивный шаг поиска в глубину состоит в переборе всех не посещённых соседей текущей вершины и переходов в них с продолжением поиска оттуда. В геометрических терминах перебор соседей и переход в них соответствует перебору рёбер текущей грани и построению грани, соседней текущей через очередное рассматриваемое ребро. Такое построение осуществляется поворотом плоскости текущей грани вокруг рассматриваемого ребра до касания какой-либо точки роя~$\Swarm$, не лежащей на рассматриваемом ребре.

  \subsection{Заворачивание подарка}
  \label{subsec:GW}

    Вход: $\Swarm \subset \R[d]$, возможна передача информации о начальной $(d-1)$\=/грани $\Facet \subset \R[d]$, она должна содержать информацию о внешней нормали.

    Выход: $d$\=/многогранник $\Polytop \subset \R[d]$.

    \begin{enumerate}

      \item Если $d = 2$, то запускается алгоритм двумерного овыпукления, например ArcHull или GrahamScan. Тогда $\Polytop$ создаётся на основе их результата.

      \item Eсли не передали начальную грань:


      \begin{enumerate}
        \item Выполняем построение начальной плоскости см.~\ref{InitialPlaneSwart} или~\ref{subsec:InitialPlaneUs}.


        \item Строим начальную грань $\Facet$ см.~\ref{FacetConstruction}.
      \end{enumerate}


      \item Запускаем поиск в глубину (\ref{subsec:DFS}) от грани $\Facet$.


      \item <<Собираем>> из полученных граней $d$\=/многогранник $\Polytop$.

      \item Конец процедуры.

    \end{enumerate}

  \subsection{Поиск в глубину}
  \label{subsec:DFS}

    Вход: $\Swarm \subset \R[d]$, $(d-1)$\=/грань $\Facet$.

    Выход: Набор $(d-1)$\=/граней.

    \begin{enumerate}
      \item Проходимся по всем $(d-2)$\=/рёбрам грани $\Facet$ и увеличиваем счётчик смежных граней на один. (Изначально он равняется нулю.)

      \item Пока у грани $\Facet$ есть рёбра со счётчиком, равным единице, повторяем:
      \begin{enumerate}
        \item Перекатываемся (\ref{subsec:RollOverEdge}) через ребро со счётчиком равным единице.


        \item Запускаем поиск в глубину (\ref{subsec:DFS}) от получившейся грани.
      \end{enumerate}

      \item Конец процедуры.

    \end{enumerate}

  \subsection{Процедура перекатывания через ребро}
  \label{subsec:RollOverEdge}
    Вход: $\Swarm \subset \R[d]$, текущая $(d-1)$\=/грань $\Facet$ и $(d-2)$\=/ребро $\Edge$ текущей грани, через которое происходит перекатывание, $(o, \Basis_{\Facet})$~--- аффинный базис плоскости содержащей грань $\Facet$. Вектор~$\vec n$~--- внешняя нормаль к грани $\Facet$.

    Выход: Новая грань $\Facet'$ и внешняя нормаль $\vec n'$ к ней.

    \begin{enumerate}
      \item Построим аффинный базис ребра $\Edge$.
      \begin{enumerate}
        \item Возьмём произвольную точку $o \in \Edge$~--- начало аффинного базиса. Положим $\Basis_\Edge = \varnothing$.

        \item Пока $|\Basis_\Edge| < d-2$: $\Basis_\Edge \leftarrow \ONorm{s_e - o}{\Basis_\Edge}$, где $s_e \in \Edge$. Если получился нулевой вектор в результате ортонормирования, то его не добавляем в базис ребра и переходим к следующей точке.
      \end{enumerate}

      \item Вычислим вектор $\vec v$, перпендикулярный оси вращения и лежащий в плоскости $\Facet$.
      \begin{enumerate}
        \item Возьмём точку $f \in \Facet \setminus \Edge$.
        \item Тогда искомый вектор равняется $\vec v = \ONorm{f - o}{\Basis_\Edge}$.
      \end{enumerate}

      \item Находим точку $s_* \in \Swarm$ такую, что $s_* \notin \Facet$, и угол между $\vec v$ и $\vec u$, наибольший среди всех точек роя (то есть $\arccos(\scalprod{\vec v}{\vec u} / \norm{\vec u})$ принимает наибольшее значение), где $\vec u = \scalprod{s - o}{\vec v \.}\vec v + \scalprod{s - o}{\vec n}\vec n$~--- вектор, перпендикулярный оси вращения и лежащий в новой плоскости, содержащей точку $s_*$. Соответствующий данной точке~$s_*$ вектор $\vec u$ обозначим $\vec r$.

      \item Тогда аффинный базис новой плоскости получается следующим: $(o, \Basis_\Edge \cup \set{\vec r \.})$.

      \item Вычислим внешнюю нормаль $\vec n'$ к новой плоскости $\Facet'$ (см.~\ref{help:OrientNormal}).

      \item Выполняем построение новой грани $\Facet'$ на точках роя, попавших в плоскость $\Plane$, проходящую через ребро $\Edge$ и точку $s$ (см. процедуру~\ref{FacetConstruction}).

      \item Конец процедуры.

    \end{enumerate}


\section{Вспомогательные процедуры}

  \subsection{Ориентирование нормали}
    \label{help:OrientNormal}
    Вход: $\Swarm \subset \R[d]$, вектор нормали $\vec n$ и точка $p$ от которой этот вектор отложен.

    Выход: Нормаль $\vec n'$ такая, что весь рой лежит в неотрицательном полупространстве относительно плоскости с нормалью $\vec n'$ и проходящей через точку $p$.

    \begin{enumerate}
      \label{help:OrientNormal.nextPoint}
      \item Возьмём очередную точку $s \in \Swarm$. Вычислим скалярное произведение $\scalprod{\vec n}{s - p}$.

      \item Если оно равно нулю, то переходим на~\ref{help:OrientNormal.nextPoint}.


      \item Если оно положительно, то меняем знак у нормали: $\vec n' \leftarrow - \vec n$. Иначе нормаль ориентирована верно и $\vec n' \leftarrow \vec n$.

      \item Конец процедуры.
    \end{enumerate}

    \subsection{Вычисление внешней нормали к плоскости}
      \label{help:CalcOuterNormal}
    Вход: $\Swarm \subset \R[d]$, плоскость $\Plane$ заданная аффинным базисом $(o, \Basis_\Plane)$.

    Выход: Нормаль $\vec n$ такая, что весь рой лежит в неотрицательном полупространстве плоскости $\Plane$.

    \begin{enumerate}
      \item Перебираем орты $e_i$ ($i=1..d$), до тех пор пока $\vec n_i = \ONorm{\vec e_i}{\Basis_\Plane}$ не станет отличным от нуля.

      \item Пусть при $i = k$, $\vec n_k \neq \ZVec$. Это искомая нормаль с точностью до ориентации. Выполним переориентирование (см.~\ref{help:OrientNormal}). Полученная нормаль будет искомой.

      \item Конец процедуры.
    \end{enumerate}




  \subsection{??? Нужна ли она ??? Процедура получения базиса плоскости, содержащего базис ребра}
    \label{help:BuildFaceBasisBasedOnEdge}
    Вход: базис $\Basis_{\Facet}$ $(d-1)$\=/грани $\Facet$, $(d-2)$\=/ребро $\Edge$ этой грани (важен набор $E$ точек, лежащих в этом ребре).

    Выход: базис $\Basis_{\Facet}$, содержащий базис ребра $\Edge$.
    \begin{enumerate}
      \item Выбираем две точки $p$, $p'$ из $E$, $p \neq p'$. Точку $p$ полагаем началом аффинного базиса, нормированный вектор $p'-p$ полагаем первым вектором $\vec b_1$ конструируемого набора~$\Basis'_{\Facet}$.
      \item Берём точку $p'' \in \Facet$, $p'' \notin E$. Вектор $p''-p$, нормированный на фоне $\vec b_1$, полагаем $(d-1)$-м вектором $\vec b_{d-1}$ конструируемого набора $\Basis'_{\Facet}$.
      \item Для всех векторов $b \in \Basis_{\Facet}$ проверяем, является ли $b$ линейно-независимым на фоне уже накопленного набора $\Basis'_{\Facet}$, и, если является, добавляем в $\Basis'_{\Facet}$ результат ортонормирования $b$ на фоне текущего набора $\Basis'_{\Facet}$.
    \end{enumerate}


\section{TODO}

  \hrule

  \bigskip

  \begin{enumerate}
    \item Перепланировать программу так, чтобы GW - конструктор объекта, из которого мы бы получали результат GW.

    \item Разумно перекидать какие-то данные в глобальные переменные экземпляра класса: в частности овыпукляемый рой, строемые грани, строящаяся информация о соседстве граней.

    \item При построении очередной грани выкидывать из роя те точки, которые были в плоскости, но не стали вершинами.
  \end{enumerate}
\end{document}