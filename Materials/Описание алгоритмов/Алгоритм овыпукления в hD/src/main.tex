% Preamble
\documentclass[a4paper,12pt]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[utf8]{inputenc}         % кодировка исходного текста
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[a4paper, margin=20mm]{geometry}

% Packages
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{mathrsfs} % \mathscr{} ажурный шрифт

\usepackage{indentfirst} %абзацный отступ
\usepackage{ifthen}      %поддержка \ifthanelse{}{}{}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[shortcuts]{extdash}


\newcommand{\R}[1][]{% R - евклидово пространство
  \ifthenelse{\equal{#1}{}}%
  {\mathbb{R}}%
  {\mathbb{R}^{#1}}}
\newcommand{\A}[1]{\mathbb{A}^{#1}}           % A - аффинное пространство
\newcommand{\Swarm}{\mathcal{S}}              % Swarm - рой точек
\newcommand{\Polyhedron}{\mathcal{P}}         % Polyhedron - многогранник
\newcommand{\PolyhedronComplex}{\mathcal{PC}} % Polyhedron Complex - многогранник
\newcommand{\Facet}{\mathcal{F}}              % Facet - грань
\newcommand{\Edge}{\mathcal{E}}               % Edge - ребро
\newcommand{\Basis}{\mathcal{B}}              % Basis - базис
\newcommand{\Viewed}{\mathcal{V}}             % Viewed - множество просмотренных точек
\newcommand{\Normal}{\mathcal{N}}             % Normal - нормаль
\newcommand{\ZVec}{\vec 0}                    % Ноль-вектор


\newcommand{\norm}[1]{\left\lVert#1\right\rVert}             % Норма
\newcommand{\set}[1]{\left\{ #1 \right\}}                    % Скобки множества
\newcommand{\scalprod}[2]{\left\langle #1, #2 \right\rangle} % Скалярное произведение
\newcommand{\Norm}[2][]{\mathcal{N}#1( #2 #1)} % Операция нормирования вектора   (первый необязательный аргумент используется для модификатора скобочек)
\newcommand{\ONorm}[3][]{\mathcal{ON}#1( #2, #3 #1)} % Операция ортонормирование вектора (первый необязательный аргумент используется для модификатора скобочек)


\newcommand{\TempVec}{\mathbf{T}}  % Temprary vector - множество временных векторов базиса
\newcommand{\FinalVec}{\mathbf{F}} % Final vector - множество финальных векторов базиса
\newcommand{\BasisOf}[1]{\mathbf{B}(#1)}   % Basis of - базис множества
\newcommand{\Plane}{\mathcal{L}}           % Плоскость
\newcommand{\SwarmPoint}{s}                % Точка роя


\renewcommand{\.}{\hspace{0.2ex}}

\begin{document}
\textbf{\centerline{Алгоритм овыпукления в $\R[d]$}}


\section{Обозначения и определения}
  $dD$ -- четырёх и более мерное пространство.

  $hD$ -- трёх- или более мерное пространство.

  Евклидово пространство $\R[d]$, $d > 1$. Его элементы обозначим $\vec x = ( x_i )_{i = 1}^{d}$.

  Ноль-вектор будем обозначать $\ZVec$.

  Аффинное пространство $\A{d}$, $d > 1$. Его элементы обозначим $x = [ x_i ]_{i = 1}^{d}$.

  Элементу $x \in \A{d}$ сопоставляется элемент $\vec x \in \R[d]$, который есть радиус\=/вектор точки $x$.

  Определены операции умножения на скаляр, сложения и вычитания. Над элементами $\R[d]$ они определяются классическим образом как операции линейного пространства. Для аффинного пространства $\A{d}$ определения следующие:
  \begin{itemize}
    \item $\forall \alpha \in \R$ $\forall x = [x_i] \in \A{d}$ $\alpha \cdot x = \alpha x = [\alpha \cdot x_i] \in \A{d}$;
    \item $\forall a \in \A{d}$ $\forall \vec x \in \R[d]$ $a + \vec x = [a_i + x_i] \in \A{d}$;
    \item $\forall a,b \in \A{d}$ $a - b = (a_i - b_i) \in \R[d]$.
  \end{itemize}

  Линейная независимость векторов из $\R[d]$ понимается в классическом смысле линейной независимости в линейном пространстве.

  Линейная независимость набора точек $\{ a_k \}_{k=0}^m \subset \A{d}$, $m \leqslant d$, понимается как линейная независимость набора векторов $\{ a_k - a_0 \}_{k=1}^m \subset \R[d]$.

  $k$\=/мерным симплексом ($k$\=/симплексом) в пространстве $\A{d}$, $k \leqslant d$, назовём линейно независимый набор $k+1$ точек.

  Базис линейного пространства $\R[d]$ понимается в классическом смысле. Аффинный базис аффинного пространства $\A{d}$ может представляться в двух эквивалентных формах: либо как $d$\=/симплекс этого пространства, либо как пару $\big(o, \{\vec x_i\}_{i=1}^d \big)$, $o \in \A{d}$, $\vec x_i \in \R[d]$, такую что набор точек $\{o, o + \vec x_i\}_{i=1}^d$ линейно независим.

  Назовём $(d-1)$\=/грань $d$\=/многогранника \textit{симплициальной}, если она имеет ровно $d$ вершин (является $(d-1)$\=/симплексом).

  %Алгоритм принимает на вход рой точек $\Swarm$ из $\R[d]$.

  %\underline{Результат -- выпуклый многогранник $\Polyhedron$}.

  Под словом <<плоскость в пространстве $\R[d]$>> будем понимать гиперплоскость размерности $\R[d-1]$.

  Вектор $\vec e_i = (\delta_{i,k})_{k=1}^d$ -- $i$\=/й вектор ортонормированного базиса $\R[d]$.
  Здесь $\delta_{i,k}$ -- символ Кр\'{о}некера:
  $$
  \delta_{i,k} =
  \begin{cases}
    1, & i=k, \\
    0, & i\neq k.
  \end{cases}
  $$

  Обозначим через $\Norm{\vec x}$ операцию нормирования вектора: $\Norm{\vec x} = \vec x \big / \norm{\vec x}$.

  Обозначим через $\ONorm{\vec v}{\Basis}$ операцию ортонормирования вектора $\vec v$ на фоне ортонормированного набора векторов $\Basis$. Выполняется с использованием алгоритма Грамма-Шмидта.


\section{Построение начальной грани $\Polyhedron$}
  Пусть $\Swarm \subset \R[d]$ -- рой $d$-мерных точек в $d$-мерном пространстве.
  Пусть $\Basis$ -- базис текущей плоскости. Построение начальной грани состоит из двух шагов. Первый -- поиск аффинной плоскости, содержащей какую-либо грань выпуклой оболочки $\Polyhedron$. Второй -- поиск вершин этой грани. Построение аффинной плоскости заключается в последовательном повороте некоторой начальной плоскости, проходящей через одну точку роя. Каждый поворот аффинной плоскости заключается в подмене одного вектора из её базиса так, чтобы она проходила через ещё хотя бы одну точку роя. Когда очередная плоскость содержит $d$ линейно независимых точек, искомая плоскость построена.

  Временные векторы базиса $\TempVec$ -- векторы из этого множества могут быть заменены.

  Финальные векторы базиса $\FinalVec$ -- векторы базиса, которые далее не будут заменяться и будут входить в базис искомой плоскости.

  Если требуется построить выпуклую оболочку в двумерном пространстве, то запускается какой-либо плоский алгоритм построения выпуклой оболочки. Иначе запускается следующий многомерный алгоритм, вообще говоря, рекурсивный по размерности овыпукляемых роёв.

  \subsection{Построение начальной плоскости $\Plane$}

    Вход: $\Swarm \subset \R[d]$ -- рой $d$-мерных точек в $d$-мерном пространстве.

    Выход: Начальная плоскость $\Plane \subset \R[d]$, заданная аффинным базисом $(o,\Basis)$, где размерность линейного базиса равна $d-1$.

    \begin{enumerate}
      \item Выберем точку $o \in \Swarm$, минимальную в лексикографическом порядке (она гарантировано будет вершиной $\Polyhedron$);

      \item Проведём через $o=(o_i)_{i = 1}^{d}$ плоскость $\Plane$ перпендикулярно первому базисному вектору пространства. (Все точки роя $\Swarm$ гарантированно лежат не левее этой плоскости.) Составим базис этой плоскости $\Basis = \set{\vec e_i}_{i=2}^d$. Положим $\FinalVec = \varnothing$, $\TempVec = \Basis$, $|\TempVec| = d-1$.

      \item Обозначим $\Viewed$ -- множество просмотренных вершин плоскости $\Plane$. Положим $\Viewed =\set{o}$.

      \item Пока $\TempVec \neq \varnothing$, повторяем:

      \begin{enumerate}
        \item Возьмём произвольный $\vec t \in \TempVec$. Удалим вектор $\vec t$ из $\TempVec$: $\TempVec \leftarrow \TempVec \setminus \set{\vec t \,}$. Будем вращать вокруг ребра, аффинный базис которого есть $(o, E)$, где $E = \FinalVec \cup \TempVec$.

        \item Возьмём произвольную точку $s \in \Swarm$, $s \notin \Viewed$. Пусть $\vec n = \ONorm{s - o}{E}$. Если $\vec n = \ZVec$ то есть набор $E \cup \set{s - o}$ линейно зависим, то добавляем точку $s$ в множество $\Viewed$ и переходим на шаг~\ref{item:search}.
        \label{item:search}

        \item Иначе найдём точку $s_* \in \Swarm$ такую, что $s_* \notin \Viewed$, и угол между $\vec n_*$ и $\vec t$ наибольший среди всех точек роя (то есть скалярное произведение $\scalprod{\vec n_*}{\vec t \;}$ наименьшее среди всех таких точек из $\Swarm$), где $\vec n_* = \ONorm{s_* - o}{E}$.

        \item Если точка $s_*$ не нашлась, это означает, что весь рой~$\Swarm$ лежит в аффинном подпространстве размерности меньше~$d-1$. В этом случае или алгоритм прекращает работу, если целью было найти выпуклую оболочку полной размерности, или переходит к построению выпуклой оболочки роя~$\Swarm$ в найденном аффинном подпространстве с базисом $(o, \FinalVec)$.

        \item  Если таких экстремальных точек несколько, то можно выбрать любую. Пусть $\vec v = \ONorm{s_* - o}{\FinalVec}$. Добавим вектор $\vec v$ в финальный базис: $\FinalVec \leftarrow \FinalVec \cup \set{\vec v \.}$. Добавим точку~$s_*$ в множество $\Viewed$.

        \item  Пересчитаем $\TempVec$ в $\TempVec'$ на фоне $\FinalVec$.
        \begin{enumerate}

          \item $\TempVec' \leftarrow \varnothing$.

          \item  Для всех векторов $\vec t \in \TempVec$:

          \item $\TempVec' \leftarrow \ONorm{\vec t}{\FinalVec \cup \TempVec'} = \ONorm{\ONorm{\vec t}{\FinalVec}}{ \TempVec'}$.
        \end{enumerate}

      \end{enumerate}
      \item Конец процедуры.
    \end{enumerate}

  \subsection{Построение грани}
    \label{subsec:FacetConstruction}

    Вход: Рой точек $\Swarm \subset \R[d]$ и плоскость $\Plane \subset \R[d]$, то есть аффинный базис $(o, \Basis)$.

    Выход: Грань $\Polyhedron \subset \R[d]$, лежащая в плоскости $\Plane$. Полученная структура данных содержит информацию о рёбрах получившейся грани.

    \begin{enumerate}
      \item Пусть теперь $\Viewed$ -- множество точек $\Swarm$, лежащих в плоскости $\Plane$.
      \item Если $|\Viewed| = d$, то полученная грань симплициальна, дальнейшая обработка не требуется. Искомая грань --- симплекс, построенный на данных $d$-точках.
      \item Иначе проецируем $\Swarm$ на $\Plane$ и строим выпуклую оболочку в аффинном подпространстве плоскости $\Plane$. Вытаскиваем $(d-1)$-мерный объект из $(d-1)$-мерного пространства грани в $d$-мерное исходное пространство так, что все дочерние объекты выражаются в терминах исходного $d$-мерного пространства.
      \item У всех получившихся рёбер увеличиваем счётчик смежных граней на один.
    \end{enumerate}


\section{Процесс заворачивания}
  Можно рассмотреть граф граней искомой выпуклой оболочки $\Polyhedron$. Вершины графа сопоставляются с гранями $\Polyhedron$. Две вершины являются соседними, если соответствующие им~$(d-1)$\=/грани имеют общее~$(d-2)$\=/ребро.

  В начале процесса заворачивания нам известна какая-то вершина этого графа, соответствующая грани, построенной алгоритмом из предыдущего раздела. Также нам известны рёбра графа, выходящие из этой вершины, так как нам известны рёбра этой начальной грани.

  В таком рассмотрении построение выпуклой оболочки соответствует обходу всех её граней, то есть обходу графа граней~$\Polyhedron$. Такой обход графа может быть осуществлён каким-либо поисковым алгоритмом. Наиболее компактную реализацию имеет алгоритм поиска в глубину. Эта реализация является рекурсивной.

  Напомним, что один рекурсивный шаг поиска в глубину состоит в переборе всех не посещённых соседей текущей вершины и переходов в них с продолжением поиска оттуда. В геометрических терминах перебор соседей и переход в них соответствует перебору рёбер текущей грани и построению грани, соседней текущей через очередное рассматриваемое ребро. Такое построение осуществляется поворотом плоскости текущей грани вокруг рассматриваемого ребра до касания какой-либо точки роя~$\Swarm$, не лежащей на рассматриваемом ребре. Такой поворот осуществляется аналогично шагу~\ref{item:search} алгоритма построения плоскости начальной грани.

  \subsection{Запуск поиска в глубину}

    Вход: $\Swarm \subset \R[d]$, возможна передача информации о начальной $(d-1)$\=/грани $\Facet \subset \R[d]$.

    Выход: $\Polyhedron \subset \R[d]$, размерности $d$.

    \begin{itemize}
      \item Для всех $(d-2)$\-/рёбер грани $\Facet$ счётчик смежных граней устанавливаем равным единице.
      \item Запускаем поиск в глубину от грани $\Facet$.
    \end{itemize}




  \subsection{Поиск в глубину}

    Имеется текущая грань $\Facet$.
    \begin{enumerate}
      \item Пока у грани $\Facet$ есть рёбра со счётчиком, равным единице, повторяем:
      \begin{enumerate}
        \item Перекатываемся через ребро со счётчиком равным единице.
        \item Всем рёбрам получившейся грани увеличиваем счётчик на один.
        \item Запускаем поиск в глубину от получившейся грани.
      \end{enumerate}
      \item Завершаем процедуру.
    \end{enumerate}

  \subsection{Процедура перекатывания через ребро}
    Дано: текущая грань $\Facet$ и ребро $\Edge$ текущей грани, через которое происходит перекатывание, $(o, \Basis_{\Facet})$~-- аффинный базис плоскости содержащей грань $\Facet$.

    \begin{enumerate}
      \item Пересчитаем аффинный базис $(o, \Basis_{\Facet})$ в другой $(p, \Basis'_{\Facet})$ такой, что $p \in \Edge$, первые $d-2$ вектора базиса $\Basis'_{\Facet}$ есть базис $\Basis_{\Edge}$ ребра $\Edge$, и $(d-1)$-й вектор $\vec v$ из $\Basis'_{\Facet}$ ортогонален $\Edge$.
      \item Находим точку $s \in \Swarm$ такую, что $s \notin \Facet$, вектор $\vec r$ есть результат ортонормирования вектора $s - p$ на фоне базиса $\Basis_{\Edge}$, и угол между векторами $\vec v$ и $\vec r$ наибольший среди всех точек роя. Если таких точек несколько можно выбрать любую.
      \item Выполняем построение новой грани $\Facet'$ на точках роя, попавших в плоскость $\Plane'$, проходящую через ребро $\Edge$ и точку $s$ (см. процедуру~\ref{subsec:FacetConstruction}). В этой процедуре следует учесть, что ребро $\Edge$ гарантированно является $(d-2)$\=/гранью конструируемой $(d-1)$\=/грани: нет нужды запускать процедуру построения начальной грани.
    \end{enumerate}

  \subsection{Процедура получения базиса плоскости, содержащего базис ребра}
    Вход: базис $\Basis_{\Facet}$ грани $\Facet$, ребро $\Edge$ (важен набор $E$ точек, лежащих в этом ребре).

    Выход: базис $\Basis_{\Edge}$.
    \begin{enumerate}
      \item Выбираем точки $p$, $p'$ из $E$, $p \neq p'$. Точку $p$ полагаем началом аффинного базиса, нормированный вектор $p'-p$ полагаем первым вектором $\vec b_1$ конструируемого набора~$\Basis'_{\Facet}$.
      \item Берём точку $p'' \in \Facet$, $p'' \notin E$. Вектор $p''-p$, нормированный на фоне $\vec b_1$, полагаем $(d-1)$-м вектором $\vec b_{d-1}$ конструируемого набора $\Basis'_{\Facet}$.
      \item Для всех векторов $b \in \Basis_{\Facet}$ проверяем, является ли $b$ линейно-независимым на фоне уже накопленного набора $\Basis'_{\Facet}$, и, если является, добавляем в $\Basis'_{\Facet}$ результат ортонормирования $b$ на фоне текущего набора $\Basis'_{\Facet}$.
    \end{enumerate}


\section{TODO}

  \hrule

\end{document}