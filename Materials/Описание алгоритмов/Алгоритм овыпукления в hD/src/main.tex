% Preamble
\documentclass[a4paper,12pt]{article}

\usepackage{cmap}                   % поиск в PDF
\usepackage[T2A]{fontenc}           % кодировка
\usepackage[utf8]{inputenc}         % кодировка исходного текста
\usepackage[english,russian]{babel} % локализация и переносы
\usepackage[a4paper, margin=20mm]{geometry}

% Packages
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} % AMS
\usepackage{mathrsfs} % \mathscr{} ажурный шрифт

\usepackage{indentfirst} %абзацный отступ
\usepackage{ifthen}      %поддержка \ifthanelse{}{}{}
\usepackage{graphicx}
\usepackage{verbatim}
\usepackage[shortcuts]{extdash}


\newcommand{\R}[1][]{% R - евклидово пространство
  \ifthenelse{\equal{#1}{}}%
  {\mathbb{R}}%
  {\mathbb{R}^{#1}}}
\newcommand{\A}[1]{\mathbb{A}^{#1}}           % A - аффинное пространство
\newcommand{\Swarm}{\mathcal{S}}              % Swarm - рой точек
\newcommand{\Polyhedron}{\mathcal{P}}         % Polyhedron - многогранник
\newcommand{\PolyhedronComplex}{\mathcal{PC}} % Polyhedron Complex - многогранник
\newcommand{\Facet}{\mathcal{F}}              % Facet - грань
\newcommand{\Edge}{\mathcal{E}}               % Edge - ребро
\newcommand{\Basis}{\mathcal{B}}              % Basis - базис
\newcommand{\Viewed}{\mathcal{V}}             % Viewed - множество просмотренных точек
\newcommand{\Normal}{\mathcal{N}}             % Normal - нормаль
\newcommand{\ZVec}{\vec 0}                    % Ноль-вектор


\newcommand{\norm}[2][]{#1\lVert #2 #1\rVert}             % Норма
\newcommand{\set}[2][]{#1\{ #2 #1\}}                    % Скобки множества
\newcommand{\scalprod}[3][]{#1\langle #2, #3 #1\rangle} % Скалярное произведение
\newcommand{\Norm}[2][]{\mathcal{N}#1( #2 #1)} % Операция нормирования вектора   (первый необязательный аргумент используется для модификатора скобочек)
\newcommand{\ONorm}[3][]{\mathcal{ON}#1( #2, #3 #1)} % Операция ортонормирование вектора (первый необязательный аргумент используется для модификатора скобочек)


\newcommand{\TempVec}{\mathbf{T}}  % Temprary vector - множество временных векторов базиса
\newcommand{\FinalVec}{\mathbf{F}} % Final vector - множество финальных векторов базиса
\newcommand{\BasisOf}[1]{\mathbf{B}(#1)}   % Basis of - базис множества
\newcommand{\Plane}{\mathcal{L}}           % Плоскость
\newcommand{\SwarmPoint}{s}                % Точка роя


\renewcommand{\.}{\hspace{0.2ex}}

\begin{document}
\textbf{\centerline{Алгоритм овыпукления в $\R[d]$}}


\section{Обозначения и определения}
  $dD$ -- четырёх и более мерное пространство.

  $hD$ -- трёх- или более мерное пространство.

  Евклидово пространство $\R[d]$, $d > 1$. Его элементы обозначим $\vec x = ( x_i )_{i = 1}^{d}$.

  Ноль-вектор будем обозначать $\ZVec$.

  Аффинное пространство $\A{d}$, $d > 1$. Его элементы обозначим $x = [ x_i ]_{i = 1}^{d}$.

  Элементу $x \in \A{d}$ сопоставляется элемент $\vec x \in \R[d]$, который есть радиус\=/вектор точки $x$.

  Определены операции умножения на скаляр, сложения и вычитания. Над элементами $\R[d]$ они определяются классическим образом как операции линейного пространства. Для аффинного пространства $\A{d}$ определения следующие:
  \begin{itemize}
    \item $\forall \alpha \in \R$ $\forall x = [x_i] \in \A{d}$ $\alpha \cdot x = \alpha x = [\alpha \cdot x_i] \in \A{d}$;
    \item $\forall a \in \A{d}$ $\forall \vec x \in \R[d]$ $a + \vec x = [a_i + x_i] \in \A{d}$;
    \item $\forall a,b \in \A{d}$ $a - b = (a_i - b_i) \in \R[d]$.
  \end{itemize}

  Линейная независимость векторов из $\R[d]$ понимается в классическом смысле линейной независимости в линейном пространстве.

  Линейная независимость набора точек $\{ a_k \}_{k=0}^m \subset \A{d}$, $m \leqslant d$, понимается как линейная независимость набора векторов $\{ a_k - a_0 \}_{k=1}^m \subset \R[d]$.

  $k$\=/мерным симплексом ($k$\=/симплексом) в пространстве $\A{d}$, $k \leqslant d$, назовём линейно независимый набор $k+1$ точек.

  Базис линейного пространства $\R[d]$ понимается в классическом смысле. Аффинный базис аффинного пространства $\A{d}$ может представляться в двух эквивалентных формах: либо как $d$\=/симплекс этого пространства, либо как пару $\big(o, \{\vec x_i\}_{i=1}^d \big)$, $o \in \A{d}$, $\vec x_i \in \R[d]$, такую что набор точек $\{o, o + \vec x_i\}_{i=1}^d$ линейно независим.

  Назовём $(d-1)$\=/грань $d$\=/многогранника \textit{симплициальной}, если она имеет ровно $d$ вершин (является $(d-1)$\=/симплексом).

  %Алгоритм принимает на вход рой точек $\Swarm$ из $\R[d]$.

  %\underline{Результат -- выпуклый многогранник $\Polyhedron$}.

  Под словом <<плоскость в пространстве $\R[d]$>> будем понимать гиперплоскость размерности $\R[d-1]$.

  Вектор $\vec e_i = (\delta_{i,k})_{k=1}^d$ -- $i$\=/й вектор ортонормированного базиса $\R[d]$.
  Здесь $\delta_{i,k}$ -- символ Кр\'{о}некера:
  $$
  \delta_{i,k} =
  \begin{cases}
    1, & i=k, \\
    0, & i\neq k.
  \end{cases}
  $$

  Обозначим через $\Norm{\vec x}$ операцию нормирования вектора: $\Norm{\vec x} = \vec x \big / \norm{\vec x}$. Считаем, что $\Norm{\ZVec} = \ZVec$.

  Обозначим через $\ONorm{\vec v \.}{\Basis}$ операцию ортонормирования вектора $\vec v$ на фоне ортонормированного набора векторов $\Basis$. Выполняется с использованием алгоритма Грамма-Шмидта. Считаем, что $\ONorm{\vec a}{\varnothing} = \Norm{\vec a}$.


\section{Построение начальной грани $\Polyhedron$}
  Пусть $\Swarm \subset \R[d]$ -- рой $d$-мерных точек в $d$-мерном пространстве.
  Пусть $\Basis$ -- базис текущей плоскости. Построение начальной грани состоит из двух шагов. Первый -- поиск аффинной плоскости, содержащей какую-либо грань выпуклой оболочки $\Polyhedron$. Второй -- поиск вершин этой грани. Построение аффинной плоскости заключается в последовательном повороте некоторой начальной плоскости, проходящей через одну точку роя. Каждый поворот аффинной плоскости заключается в подмене одного вектора из её базиса так, чтобы она проходила через ещё хотя бы одну точку роя. Когда очередная плоскость содержит $d$ линейно независимых точек, искомая плоскость построена.

  Временные векторы базиса $\TempVec$ -- векторы из этого множества могут быть заменены.

  Финальные векторы базиса $\FinalVec$ -- векторы базиса, которые далее не будут заменяться и будут входить в базис искомой плоскости.

  Если требуется построить выпуклую оболочку в двумерном пространстве, то запускается какой-либо плоский алгоритм построения выпуклой оболочки. Иначе запускается следующий многомерный алгоритм, вообще говоря, рекурсивный по размерности овыпукляемых роёв.

  \subsection{Построение начальной плоскости $\Plane$}
  \label{subsec:InitialPlane}

    Вход: $\Swarm \subset \R[d]$ -- рой точек в $d$-мерном пространстве.

    Выход: Начальная плоскость $\Plane \subset \R[d]$, заданная аффинным базисом $(o,\Basis)$, где размерность линейного базиса равна $d-1$. Внешняя нормаль $\vec n$ к этой плоскости.

    \begin{enumerate}
      \item Выберем точку $o \in \Swarm$, минимальную в лексикографическом порядке (она гарантировано будет вершиной $\Polyhedron$);

      \item Проведём через $o=(o_i)_{i = 1}^{d}$ плоскость $\Plane$ перпендикулярно первому базисному вектору пространства. (Все точки роя $\Swarm$ гарантированно лежат не левее этой плоскости.) Положим $\FinalVec_0 = \varnothing$, $\TempVec_0 =  \set{\vec e_i}_{i=2}^d$.

      \item Положим нормаль к плоскости $\vec n_0 = -\vec e_1$.

      \item Обозначим $\Viewed$ -- множество просмотренных точек плоскости $\Plane$. Положим $\Viewed =\set{o}$.

      \item Пока $\TempVec \neq \varnothing$, повторяем:

      \begin{enumerate}
        \item Имеем $\vec n_k$ --- нормаль к текущей плоскости, $\FinalVec_k$ --- накопленная часть базиса плоскости такая, что $(o, \FinalVec_k)$ --- аффинный базис тех точек, которые уже просмотрены и включены в плоскость. $\TempVec_k$ --- оставшаяся часть временного базиса.

        \item Возьмём произвольный $\vec t \in \TempVec_k$. Удалим вектор $\vec t$ из $\TempVec_k$: $\TempVec_{k+1} \leftarrow \TempVec_k \setminus \set{\vec t \,}$.

        \item Вычислим вектор $\vec v$, перпендикулярный оси вращения: $\vec v = \ONorm{\vec t}{\FinalVec_k}$.

        \item Возьмём произвольную точку $s \in \Swarm$, $s \notin \Viewed$. Рассмотрим вектор $\vec u = \scalprod{s - o}{\vec v \.}\vec v + \scalprod{s - o}{\vec n_k}\vec n_k$~--- вектор, перпендикулярный оси вращения и лежащий в новой плоскости, содержащей точку $s$. Если $\vec u = \ZVec$, то есть точка $s$ лежит в оси вращения, то добавляем точку $s$ в множество $\Viewed$ и переходим на шаг~\ref{item:search}.
        \label{item:search}

        \item Иначе найдём точку $s_* \in \Swarm$ такую, что $s_* \notin \Viewed$, и угол между $\vec v$ и $\vec u$, наибольший среди всех точек роя (то есть скалярное произведение $\scalprod{\vec v \.}{\Norm{\vec u}}$, наименьшее среди всех таких точек из $\Swarm$).

        \item Если точка $s_*$ не нашлась, это означает, что весь рой~$\Swarm$ лежит в аффинном подпространстве размерности меньше~$d-1$. В этом случае или алгоритм прекращает работу, если целью было найти выпуклую оболочку полной размерности, или переходит к построению выпуклой оболочки роя~$\Swarm$ в найденном аффинном подпространстве с базисом $(o, \FinalVec_k)$.
        \label{item:stop}

        \item  Если таких экстремальных точек несколько, то можно выбрать любую. Расширим финальный базис: $\FinalVec_{k+1} \leftarrow \FinalVec_k \cup \set[\big]{\ONorm{s_* - o}{\FinalVec_k}}$. Добавим точку~$s_*$ в множество~$\Viewed$.

        \item Вычислим нормаль $\vec n_{k+1}$ новой плоскости: $\vec n_{k+1} = \scalprod{\vec u\.^*}{\vec n_k}\vec v - \scalprod{\vec u\.^*}{\vec v \.}\vec n_k$. При необходимости надо переориентировать $\vec n_{k+1}$ так, чтобы $\scalprod{\vec n_{k+1}}{s - o} < 0$, где~$s$~---~точка роя, не лежащая в текущей плоскости, то есть такая, что $\scalprod{\vec n_{k+1}}{s - o} \neq 0$. Если такой точки не нашлось, значит все точки лежат в аффинном подпространстве с базисом $(o, \FinalVec_{k+1})$. Аналогично пункту~\ref{item:stop} либо останавливаем алгоритм, либо переходим к построению выпуклой оболочки в этом аффинном подпространстве.



      \end{enumerate}
      \item Положим $\Basis = F_k$, $\vec n = \vec n_k$.
    \end{enumerate}

  \subsection{Построение грани}
    \label{subsec:FacetConstruction}

    Вход: Рой точек $\Swarm \subset \R[d]$ и плоскость $\Plane \subset \R[d]$, то есть аффинный базис $(o, \Basis)$. Возможна передача $(d-2)$\=/ребра $\Edge$, являющегося начальной гранью для процедуры овыпукления в $(d-1)$\=/пространстве плоскости $\Plane$.

    Выход: $(d-1)$\=/грань $\Facet \subset \R[d]$, лежащая в плоскости $\Plane$.

    \begin{enumerate}
      \item Пусть теперь $\Viewed$ -- множество точек $\Swarm$, лежащих в плоскости $\Plane$.
      \item Если $|\Viewed| = d$, то полученная грань симплициальна, дальнейшая обработка не требуется. Искомая грань --- симплекс, построенный на $d$ данных точках.
      \item Иначе проецируем $\Swarm$ на $\Plane$ (предварительно запоминая из какой точки $s \in \Swarm$ получилась очередная точка $s' \in \Plane$) и строим выпуклую оболочку в аффинном подпространстве плоскости $\Plane$, если передано ребро $\Edge$, то проецируем его на $\Plane$ и также в процедуру овыпукления в подпространстве. Полученный $(d-1)$\=/многогранник выражен в терминах $(d-1)$\=/пространства, поэтому <<поднимаем>> его в $d$-мерное исходное пространство: очередную вершину $s'$ подменяем исходной для неё точкой $s$. Производим аналогичную операцию для всех дочерних объектов данного многогранника.
    \end{enumerate}


\section{Процесс заворачивания}
  Можно рассмотреть граф граней искомой выпуклой оболочки $\Polyhedron$. Вершины графа сопоставляются с гранями $\Polyhedron$. Две вершины являются соседними, если соответствующие им~$(d-1)$\=/грани имеют общее~$(d-2)$\=/ребро.

  В начале процесса заворачивания нам известна какая-то вершина этого графа, соответствующая грани, построенной алгоритмом из предыдущего раздела. Также нам известны рёбра графа, выходящие из этой вершины, так как нам известны рёбра этой начальной грани.

  В таком рассмотрении построение выпуклой оболочки соответствует обходу всех её граней, то есть обходу графа граней~$\Polyhedron$. Такой обход графа может быть осуществлён каким-либо поисковым алгоритмом. Наиболее компактную реализацию имеет алгоритм поиска в глубину. Эта реализация является рекурсивной.

  Напомним, что один рекурсивный шаг поиска в глубину состоит в переборе всех не посещённых соседей текущей вершины и переходов в них с продолжением поиска оттуда. В геометрических терминах перебор соседей и переход в них соответствует перебору рёбер текущей грани и построению грани, соседней текущей через очередное рассматриваемое ребро. Такое построение осуществляется поворотом плоскости текущей грани вокруг рассматриваемого ребра до касания какой-либо точки роя~$\Swarm$, не лежащей на рассматриваемом ребре. Такой поворот осуществляется аналогично шагу~\ref{item:search} алгоритма построения плоскости начальной грани.

  \subsection{Запуск поиска в глубину}

    Вход: $\Swarm \subset \R[d]$, возможна передача информации о начальной $(d-1)$\=/грани $\Facet \subset \R[d]$.

    Выход: $d$-многогранник $\Polyhedron \subset \R[d]$.

    \begin{itemize}
      \item Eсли не передали начальную грань:
      \begin{enumerate}
        \item Выполняем построение начальной плоскости см.~\ref{subsec:InitialPlane}.
        \item Строим начальную грань $\Facet$ см.~\ref{subsec:FacetConstruction}.
      \end{enumerate}
      \item Для всех $(d-2)$\-/рёбер грани $\Facet$ счётчик смежных граней устанавливаем равным единице.
      \item Запускаем поиск в глубину от грани $\Facet$.
    \end{itemize}




  \subsection{Поиск в глубину}

    Имеется текущая грань $\Facet$.
    \begin{enumerate}
      \item Пока у грани $\Facet$ есть рёбра со счётчиком, равным единице, повторяем:
      \begin{enumerate}
        \item Перекатываемся через ребро со счётчиком равным единице.
        \item Всем рёбрам получившейся грани увеличиваем счётчик на один.
        \item Запускаем поиск в глубину от получившейся грани.
      \end{enumerate}
      \item Завершаем процедуру.
    \end{enumerate}

  \subsection{Процедура перекатывания через ребро}
    Вход: $\Swarm \in \R[d]$, текущая $(d-1)$\=/грань $\Facet$ и $(d-2)$\=/ребро $\Edge$ текущей грани, через которое происходит перекатывание, $(o, \Basis_{\Facet})$~--- аффинный базис плоскости содержащей грань $\Facet$. Вектор~$\vec n$~--- нормаль грани $\Facet$.

    Выход: Новая грань $\Facet$ и внешняя нормаль к ней.

    \begin{enumerate}
      \item Построим аффинный базис ребра $\Edge$.
      \begin{enumerate}
        \item Возьмём произвольную точку $o \in \Edge$~--- начало аффинного базиса. Положим $\Basis_\Edge = \varnothing$.

        \item Пока $|\Basis_\Edge| < d-2$: $\Basis_\Edge \leftarrow \ONorm{s_e - o}{\Basis_\Edge}$, где $s_e \in \Edge$.
      \end{enumerate}

      \item Вычислим вектор $\vec v$, перпендикулярный оси вращения и лежащий в плоскости $\Facet$.
      \begin{enumerate}
        \item Возьмём точку $f \in \Facet \setminus \Edge$.
        \item Тогда искомый вектор равняется $\vec v = \ONorm{f - o}{\Basis_\Edge}$.
      \end{enumerate}

      \item Находим точку $s_* \in \Swarm$ такую, что $s_* \notin \Facet$, и угол между $\vec v$ и $\vec u$, наибольший среди всех точек роя (то есть скалярное произведение $\scalprod{\vec v \.}{\Norm{\vec u}}$, наименьшее среди всех таких точек из $\Swarm$), где $\vec u = \scalprod{s - o}{\vec v \.}\vec v + \scalprod{s - o}{\vec n}\vec n$~--- вектор, перпендикулярный оси вращения и лежащий в новой плоскости, содержащей точку $s_*$. Соответствующий такой точке~$s_*$ вектор $\vec u$ обозначим $\vec r$.

      \item Аффинный базис плоскости $\Plane \triangleq (o, \Basis_\Edge \cup \set{\vec r \.})$.

      \item Вычислим нормаль $\vec n_{*}$ новой плоскости: $\vec n_{*} = \scalprod{\vec r}{\vec n}\vec v - \scalprod{\vec r}{\vec v \.}\vec n$. При необходимости надо переориентировать $\vec n_{*}$ так, чтобы $\scalprod{\vec n_{*}}{s - o} < 0$, где~$s$~--- точка роя, не лежащая в текущей плоскости $\Facet$, то есть такая, что $\scalprod{\vec n_{*}}{s - o} \neq 0$.

      \item Выполняем построение новой грани $\Facet'$ на точках роя, попавших в плоскость $\Plane$, проходящую через ребро $\Edge$ и точку $s$ (см. процедуру~\ref{subsec:FacetConstruction}).

      РАСШИРИТЬ ПУНКТ. ПРОЕКТИРОВАНИЕ И ВОЗВРАТ.
    \end{enumerate}

  \subsection{Процедура получения базиса плоскости, содержащего базис ребра}
    Вход: базис $\Basis_{\Facet}$ $(d-1)$\=/грани $\Facet$, $(d-2)$\=/ребро $\Edge$ этой грани (важен набор $E$ точек, лежащих в этом ребре).

    Выход: базис $\Basis_{\Facet}$, содержащий базис ребра $\Edge$.
    \begin{enumerate}
      \item Выбираем две точки $p$, $p'$ из $E$, $p \neq p'$. Точку $p$ полагаем началом аффинного базиса, нормированный вектор $p'-p$ полагаем первым вектором $\vec b_1$ конструируемого набора~$\Basis'_{\Facet}$.
      \item Берём точку $p'' \in \Facet$, $p'' \notin E$. Вектор $p''-p$, нормированный на фоне $\vec b_1$, полагаем $(d-1)$-м вектором $\vec b_{d-1}$ конструируемого набора $\Basis'_{\Facet}$.
      \item Для всех векторов $b \in \Basis_{\Facet}$ проверяем, является ли $b$ линейно-независимым на фоне уже накопленного набора $\Basis'_{\Facet}$, и, если является, добавляем в $\Basis'_{\Facet}$ результат ортонормирования $b$ на фоне текущего набора $\Basis'_{\Facet}$.
    \end{enumerate}


\section{TODO}

  \hrule

  \begin{enumerate}
    \item Переписать 3.3 (Пункты 1 и 2)
    \item Переделать программу
    \item Сравнить производительность.
  \end{enumerate}
\end{document}